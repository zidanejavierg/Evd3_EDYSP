import datetime
import csv
import os
import json
import sqlite3
from openpyxl import Workbook
from openpyxl.styles import Font, Alignment, Border, Side

# Datos en memoria 
lista_clientes, lista_salas, lista_reservas = {}, {}, {}
contador_folio, contador_clientes, contador_salas = 1, 1, 1
archivo_datos = "estado_reservas.csv"
archivo_db = "estado_reservas.db"

def init_db():
    nueva_db = not os.path.exists(archivo_db)
    conn = sqlite3.connect(archivo_db)
    cur = conn.cursor()
    cur.execute("""
        CREATE TABLE IF NOT EXISTS clientes (
            id INTEGER PRIMARY KEY,
            nombre TEXT NOT NULL,
            apellidos TEXT NOT NULL
        )
    """)
    cur.execute("""
        CREATE TABLE IF NOT EXISTS salas (
            id INTEGER PRIMARY KEY,
            nombre TEXT NOT NULL,
            cupo INTEGER NOT NULL
        )
    """)
    cur.execute("""
        CREATE TABLE IF NOT EXISTS reservas (
            folio INTEGER PRIMARY KEY,
            cliente_id INTEGER NOT NULL,
            sala_id INTEGER NOT NULL,
            fecha TEXT NOT NULL,
            turno TEXT NOT NULL,
            evento TEXT NOT NULL,
            cancelado INTEGER NOT NULL DEFAULT 0,
            FOREIGN KEY(cliente_id) REFERENCES clientes(id),
            FOREIGN KEY(sala_id) REFERENCES salas(id)
        )
    """)
    conn.commit()

    # Verificar si existe la columna 'cancelado' y agregarla si falta
    cur.execute("PRAGMA table_info(reservas)")
    columnas = [fila[1] for fila in cur.fetchall()]
    if "cancelado" not in columnas:
        print("Actualizando base de datos: agregando columna 'cancelado'...")
        cur.execute("ALTER TABLE reservas ADD COLUMN cancelado INTEGER NOT NULL DEFAULT 0")
        conn.commit()

    conn.close()

    # Mostrar mensaje seg√∫n el estado de la base
    if nueva_db:
        print("Se inicia con un estado inicial vac√≠o, base de datos iniciada.")
    else:
        print("Version anterior recuperada")

def save_client_to_db(cid, nombre, apellidos):
    conn = sqlite3.connect(archivo_db)
    cur = conn.cursor()
    cur.execute("INSERT OR REPLACE INTO clientes(id,nombre,apellidos) VALUES(?,?,?)", (cid, nombre, apellidos))
    conn.commit()
    conn.close()

def save_sala_to_db(sid, nombre, cupo):
    conn = sqlite3.connect(archivo_db)
    cur = conn.cursor()
    cur.execute("INSERT OR REPLACE INTO salas(id,nombre,cupo) VALUES(?,?,?)", (sid, nombre, cupo))
    conn.commit()
    conn.close()

def save_reserva_to_db(folio, cliente_id, sala_id, fecha, turno, evento, cancelado=0):
    conn = sqlite3.connect(archivo_db)
    cur = conn.cursor()
    cur.execute("""INSERT OR REPLACE INTO reservas(folio,cliente_id,sala_id,fecha,turno,evento,cancelado)
                   VALUES(?,?,?,?,?,?,?)""", (folio, cliente_id, sala_id, fecha.strftime("%m-%d-%Y"), turno, evento, cancelado))
    conn.commit()
    conn.close()

def update_reserva_event_db(folio, nuevo_evento):
    conn = sqlite3.connect(archivo_db)
    cur = conn.cursor()
    cur.execute("UPDATE reservas SET evento = ? WHERE folio = ?", (nuevo_evento, folio))
    conn.commit()
    conn.close()

def marcar_reserva_cancelada_db(folio):
    conn = sqlite3.connect(archivo_db)
    cur = conn.cursor()
    cur.execute("UPDATE reservas SET cancelado = 1 WHERE folio = ?", (folio,))
    conn.commit()
    conn.close()

def cargar_estado():
    global lista_clientes, lista_salas, lista_reservas
    global contador_folio, contador_clientes, contador_salas

    init_db()
    conn = sqlite3.connect(archivo_db)
    cur = conn.cursor()

    cur.execute("SELECT id,nombre,apellidos FROM clientes")
    filas = cur.fetchall()
    for row in filas:
        cid, nombre, apellidos = row
        lista_clientes[cid] = {"nombre": nombre, "apellidos": apellidos}
        if cid >= contador_clientes:
            contador_clientes = cid + 1

    cur.execute("SELECT id,nombre,cupo FROM salas")
    filas = cur.fetchall()
    for row in filas:
        sid, nombre, cupo = row
        lista_salas[sid] = {"nombre": nombre, "cupo": cupo}
        if sid >= contador_salas:
            contador_salas = sid + 1

    cur.execute("SELECT folio,cliente_id,sala_id,fecha,turno,evento,cancelado FROM reservas")
    filas = cur.fetchall()
    for row in filas:
        folio, cliente_id, sala_id, fecha_str, turno, evento, cancelado = row
        try:
            fecha = datetime.datetime.strptime(fecha_str, "%m-%d-%Y").date()
        except Exception:
            continue
        lista_reservas[folio] = {
            "cliente": cliente_id,
            "sala": sala_id,
            "fecha": fecha,
            "turno": turno,
            "evento": evento,
            "cancelado": bool(cancelado)
        }
        if folio >= contador_folio:
            contador_folio = folio + 1

    conn.close()


def generar_folio():
    global contador_folio
    folio_actual = contador_folio
    contador_folio += 1
    return folio_actual

def validar_fecha(cadena, minimo2dias=True):
    try:
        fecha_ingresada = datetime.datetime.strptime(cadena, "%m-%d-%Y").date()
    except:
        print("Formato de fecha inv√°lido. Usa mm-dd-yyyy.")
        return None

    hoy = datetime.date.today()

    if minimo2dias and fecha_ingresada < hoy + datetime.timedelta(days=2):
        print("La fecha debe ser al menos dos d√≠as despu√©s de la fecha actual.")
        return None

    if fecha_ingresada.weekday() == 6:
        lunes_siguiente = fecha_ingresada + datetime.timedelta(days=1)
        print(f"La fecha ingresada ({fecha_ingresada.strftime('%m-%d-%Y')}) cae en domingo.")
        print(f"Se propone el lunes siguiente ({lunes_siguiente.strftime('%m-%d-%Y')}).")
        aceptar = input("¬øDeseas usar la fecha propuesta? (S/N): ").strip().upper()
        if aceptar == "S":
            return lunes_siguiente
        else:
            print("Por favor ingresa una nueva fecha v√°lida.")
            return None

    return fecha_ingresada

def mostrar_clientes():
    if not lista_clientes:
        print("No hay clientes registrados.")
        return []
    ordenados = sorted(lista_clientes.items(), key=lambda x: (x[1]['apellidos'], x[1]['nombre']))
    print("\nLista de clientes registrados:")
    for clave, datos in ordenados:
        print(f"{clave}: {datos['apellidos']} {datos['nombre']}")
    return [c[0] for c in ordenados]

def elegir_cliente():
    while True:
        claves_disponibles = mostrar_clientes()
        if not claves_disponibles: return None
        opcion = input("Ingresa la clave del cliente (o C para cancelar): ").upper()
        if opcion == "C": return None
        if opcion.isdigit() and int(opcion) in claves_disponibles:
            return int(opcion)
        print("Clave inv√°lida, vuelve a intentarlo.")

def mostrar_salas_disponibles(fecha, turno):
    disponibles = []
    for clave, datos in lista_salas.items():
        ocupado = any(
            (r['sala'] == clave and r['fecha'] == fecha and r['turno'] == turno and not r.get('cancelado', False))
            for r in lista_reservas.values()
        )
        if not ocupado:
            print(f"{clave}: {datos['nombre']} (Cupo {datos['cupo']})")
            disponibles.append(clave)
    if not disponibles:
        print("No hay salas disponibles.")
    return disponibles

def elegir_sala(fecha, turno):
    while True:
        disponibles = mostrar_salas_disponibles(fecha, turno)
        if not disponibles: return None
        opcion = input("Ingresa la clave de la sala (o C para cancelar): ").upper()
        if opcion == "C": return None
        if opcion.isdigit() and int(opcion) in disponibles:
            return int(opcion)
        print("Clave inv√°lida, vuelve a intentarlo.")

def reporte_fecha(fecha):
    print(f"\nReservas para el {fecha.strftime('%m-%d-%Y')}:")
    print(f"{'Folio':<6} {'Cliente':<25} {'Sala':<15} {'Turno':<10} {'Evento':<20}")
    print("-"*80)
    encontrado = False
    for folio,res in lista_reservas.items():
        if res.get('cancelado', False):
            continue
        if res['fecha']==fecha:
            cli = lista_clientes[res['cliente']]
            sala = lista_salas[res['sala']]
            nombre_cliente = f"{cli['apellidos']} {cli['nombre']}"
            print(f"{folio:<6} {nombre_cliente:<25} {sala['nombre']:<15} {res['turno']:<10} {res['evento']:<20}")
            encontrado = True
    if not encontrado:
        print("No hay reservas registradas para esa fecha.")
    return encontrado

def exportar_csv(fecha):
    nombre_archivo = f"reporte_{fecha.strftime('%m-%d-%Y')}.csv"
    with open(nombre_archivo, "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerow(["Folio", "Cliente", "Sala", "Turno", "Evento"])
        for folio, res in lista_reservas.items():
            if res.get('cancelado', False):
                continue
            if res['fecha'] == fecha:
                cli = lista_clientes[res['cliente']]
                sala = lista_salas[res['sala']]
                writer.writerow([folio, f"{cli['apellidos']} {cli['nombre']}", sala['nombre'], res['turno'], res['evento']])
    print(f"Reporte exportado como {nombre_archivo}")

def exportar_json(fecha):
    nombre_archivo = f"reporte_{fecha.strftime('%m-%d-%Y')}.json"
    datos = []
    for folio, res in lista_reservas.items():
        if res.get('cancelado', False):
            continue
        if res['fecha'] == fecha:
            cli = lista_clientes[res['cliente']]
            sala = lista_salas[res['sala']]
            datos.append({
                "Folio": folio,
                "Cliente": f"{cli['apellidos']} {cli['nombre']}",
                "Sala": sala['nombre'],
                "Turno": res['turno'],
                "Evento": res['evento']
            })
    with open(nombre_archivo, "w", encoding="utf-8") as f:
        json.dump(datos, f, ensure_ascii=False, indent=4)
    print(f"Reporte exportado como {nombre_archivo}")

def exportar_excel(fecha):
    nombre_archivo = f"reporte_{fecha.strftime('%m-%d-%Y')}.xlsx"
    wb = Workbook()
    ws = wb.active
    ws.title = "Reservaciones"

    encabezados = ["Folio", "Cliente", "Sala", "Turno", "Evento"]
    bold = Font(bold=True)
    center = Alignment(horizontal="center")
    border = Border(bottom=Side(style="thick"))

    for i, titulo in enumerate(encabezados, 1):
        celda = ws.cell(row=1, column=i, value=titulo)
        celda.font = bold
        celda.alignment = center
        celda.border = border

    fila = 2
    for folio, res in lista_reservas.items():
        if res.get('cancelado', False):
            continue
        if res['fecha'] == fecha:
            cli = lista_clientes[res['cliente']]
            sala = lista_salas[res['sala']]
            ws.append([folio, f"{cli['apellidos']} {cli['nombre']}", sala['nombre'], res['turno'], res['evento']])
            for c in ws[fila]:
                c.alignment = center
            fila += 1

    wb.save(nombre_archivo)
    print(f"Reporte exportado como {nombre_archivo}")

def registrar_cliente():
    global contador_clientes
    while True:
        nombre = input("Nombre del cliente (o C para cancelar): ").strip()
        if nombre.upper() == "C":
            return
        if not nombre:
            print("El nombre no puede quedar vac√≠o.")
            continue
        if not all(c.isalpha() or c.isspace() for c in nombre):
            print("El nombre solo puede contener letras y espacios.")
            continue
        break

    while True:
        apellidos = input("Apellidos del cliente (o C para cancelar): ").strip()
        if apellidos.upper() == "C":
            return
        if not apellidos:
            print("Los apellidos no pueden quedar vac√≠os.")
            continue
        if not all(c.isalpha() or c.isspace() for c in apellidos):
            print("Los apellidos solo pueden contener letras y espacios.")
            continue
        break

    cid = contador_clientes
    lista_clientes[cid] = {"nombre": nombre, "apellidos": apellidos}
    save_client_to_db(cid, nombre, apellidos)
    print(f"Cliente registrado con clave {cid}")
    contador_clientes += 1
def registrar_sala():
    global contador_salas
    while True:
        nombre = input("Nombre de la sala (o C para cancelar): ").strip()
        if nombre.upper() == "C": return
        if nombre: break
        print("El nombre de la sala no puede quedar vac√≠o.")
    while True:
        cupo = input("Cupo de la sala (o C para cancelar): ").strip()
        if cupo.upper() == "C": return
        try:
            cupo = int(cupo)
            if cupo > 0: break
            else: print("El cupo debe ser mayor a 0.")
        except:
            print("Ingresa un n√∫mero v√°lido.")
    sid = contador_salas
    lista_salas[sid] = {"nombre":nombre, "cupo":cupo}
    save_sala_to_db(sid, nombre, cupo)
    print(f"Sala registrada con clave {sid}")
    contador_salas += 1

def registrar_reserva():
    cliente = elegir_cliente()
    if not cliente: return
    fecha = None
    while not fecha:
        f = input("Fecha de la reserva (mm-dd-yyyy) o C para cancelar: ").strip()
        if f.upper() == "C": return
        fecha = validar_fecha(f)
    turno = input("Turno (M=Matutino, V=Vespertino, N=Nocturno o C para cancelar): ").upper()
    if turno == "C": return
    if turno not in ["M","V","N"]:
        print("Turno inv√°lido.")
        return
    sala = elegir_sala(fecha, turno)
    if not sala: return
    evento = ""
    while not evento.strip():
        evento = input("Nombre del evento (o C para cancelar): ").strip()
        if evento.upper() == "C": return
        if not evento.strip():
            print("El evento no puede quedar vac√≠o.")
    folio = generar_folio()
    lista_reservas[folio] = {"cliente":cliente, "sala":sala, "fecha":fecha, "turno":turno, "evento":evento, "cancelado":False}
    save_reserva_to_db(folio, cliente, sala, fecha, turno, evento, 0)
    print(f"Reserva registrada con folio {folio}")

def editar_evento():
    #Verificar si hay reservas antes de continuar
    if not lista_reservas:
        print("No hay reservas registradas.")
        return

    while True:
        entrada_f1 = input("Fecha inicio (mm-dd-yyyy) o C para cancelar: ").strip()
        if entrada_f1.upper() == "C":
            print("Operaci√≥n cancelada.")
            return
        f1 = validar_fecha(entrada_f1, False)
        if not f1:
            print("Fecha de inicio inv√°lida, intenta de nuevo o ingresa C para cancelar.")
            continue

        entrada_f2 = input("Fecha fin (mm-dd-yyyy) o C para cancelar: ").strip()
        if entrada_f2.upper() == "C":
            print("Operaci√≥n cancelada.")
            return
        f2 = validar_fecha(entrada_f2, False)
        if not f2:
            print("Fecha de fin inv√°lida, intenta de nuevo o ingresa C para cancelar.")
            continue

        if f1 > f2:
            print("Rango inv√°lido: la fecha de inicio es posterior a la fecha fin. Intenta de nuevo.")
            continue

        break

    rango = {
        folio: res
        for folio, res in lista_reservas.items()
        if f1 <= res['fecha'] <= f2 and not res.get('cancelado', False)
    }

    if not rango:
        print("No hay reservas en ese rango.")
        return

    while True:
        print(f"{'Folio':<6} {'Evento':<25} {'Fecha':<15}")
        for folio, res in rango.items():
            print(f"{folio:<6} {res['evento']:<25} {res['fecha'].strftime('%m-%d-%Y'):<15}")
        op = input("Folio a editar (o C para cancelar): ").upper().strip()
        if op == "C":
            print("Operaci√≥n cancelada.")
            return
        if op.isdigit() and int(op) in rango:
            nuevo = ""
            while not nuevo.strip():
                nuevo = input("Nuevo nombre del evento (o C para cancelar): ").strip()
                if nuevo.upper() == "C":
                    print("Operaci√≥n cancelada.")
                    return
                if not nuevo.strip():
                    print("El nombre no puede quedar vac√≠o.")
            folio_int = int(op)
            lista_reservas[folio_int]['evento'] = nuevo
            update_reserva_event_db(folio_int, nuevo)
            print("Evento actualizado.")
            return
        print("Folio inv√°lido, vuelve a intentarlo o ingresa C para cancelar.")


def cancelar_reserva():
    #Verificar si hay reservas antes de continuar
    if not lista_reservas:
        print("No hay reservas registradas.")
        return

    hoy = datetime.date.today()
    dos_dias_despues = hoy + datetime.timedelta(days=2)

    while True:
        entrada_f1 = input("Fecha inicio del rango (mm-dd-yyyy) o C para cancelar: ").strip()
        if entrada_f1.upper() == "C":
            print("Operaci√≥n cancelada.")
            return
        f1 = validar_fecha(entrada_f1, False)
        if not f1:
            print("Fecha de inicio inv√°lida, intenta de nuevo o ingresa C para cancelar.")
            continue

        # üîπ Mensaje inmediato si la fecha es menor a dos d√≠as posteriores
        if f1 < dos_dias_despues:
            print(f"\nÔ∏è La fecha de inicio {f1.strftime('%m-%d-%Y')} es menor a dos d√≠as posteriores "
                  f"({dos_dias_despues.strftime('%m-%d-%Y')}).")
            uso = input(f"¬øDeseas usar {dos_dias_despues.strftime('%m-%d-%Y')} como fecha inicio? (S/N): ").strip().upper()
            if uso == "S":
                f1 = dos_dias_despues
                print(f"Se usar√° {f1.strftime('%m-%d-%Y')} como fecha inicio.\n")
            else:
                print("Continuando con la fecha original.\n")

        entrada_f2 = input("Fecha fin del rango (mm-dd-yyyy) o C para cancelar: ").strip()
        if entrada_f2.upper() == "C":
            print("Operaci√≥n cancelada.")
            return
        f2 = validar_fecha(entrada_f2, False)
        if not f2:
            print("Fecha de fin inv√°lida, intenta de nuevo o ingresa C para cancelar.")
            continue

        if f1 > f2:
            print("Rango inv√°lido: la fecha de inicio es posterior a la fecha fin. Intenta de nuevo.")
            continue

        break

    rango = {
        folio: res
        for folio, res in lista_reservas.items()
        if f1 <= res['fecha'] <= f2 and not res.get('cancelado', False)
    }

    if not rango:
        print("No hay reservas no canceladas en ese rango.")
        return

    print(f"\n{'Folio':<6} {'Cliente':<25} {'Sala':<15} {'Fecha':<12} {'Turno':<6} {'Evento':<20}")
    for folio, res in rango.items():
        cli = lista_clientes[res['cliente']]
        sala = lista_salas[res['sala']]
        nombre_cliente = f"{cli['apellidos']} {cli['nombre']}"
        print(f"{folio:<6} {nombre_cliente:<25} {sala['nombre']:<15} {res['fecha'].strftime('%m-%d-%Y'):<12} {res['turno']:<6} {res['evento']:<20}")

    while True:
        sel = input("\nIngresa el folio que deseas cancelar (o C para cancelar operaci√≥n): ").strip().upper()
        if sel == "C":
            print("Operaci√≥n cancelada.")
            return
        if not sel.isdigit() or int(sel) not in rango:
            print("Folio inv√°lido, intenta de nuevo o ingresa C para cancelar.")
            continue

        folio_sel = int(sel)
        reserva = lista_reservas[folio_sel]

        if reserva['fecha'] < dos_dias_despues:
            print(f"La reserva con folio {folio_sel} tiene fecha {reserva['fecha'].strftime('%m-%d-%Y')} "
                  f"y no cumple con los 2 d√≠as de anticipaci√≥n. Operaci√≥n rechazada.")
            return

        confirmar = input(
            f"Confirmas la cancelaci√≥n de la reserva {folio_sel} "
            f"(Evento: {reserva['evento']}, Fecha: {reserva['fecha'].strftime('%m-%d-%Y')})? (S/N): "
        ).strip().upper()

        if confirmar == "S":
            lista_reservas[folio_sel]['cancelado'] = True
            marcar_reserva_cancelada_db(folio_sel)
            print(f"Reserva {folio_sel} registrada como CANCELADA. Disponibilidad recuperada.")
            return
        else:
            print("Cancelaci√≥n abortada por el usuario.")
            return


def cancelar_reserva():
    #Verificar si hay reservas antes de continuar
    if not lista_reservas:
        print("No hay reservas registradas.")
        return

    hoy = datetime.date.today()
    dos_dias_despues = hoy + datetime.timedelta(days=2)

    while True:
        entrada_f1 = input("Fecha inicio del rango (mm-dd-yyyy) o C para cancelar: ").strip()
        if entrada_f1.upper() == "C":
            print("Operaci√≥n cancelada.")
            return
        f1 = validar_fecha(entrada_f1, False)
        if not f1:
            print("Fecha de inicio inv√°lida, intenta de nuevo o ingresa C para cancelar.")
            continue

        #Mensaje inmediato si la fecha es menor a dos d√≠as posteriores
        if f1 < dos_dias_despues:
            print(f"\nÔ∏è La fecha de inicio {f1.strftime('%m-%d-%Y')} es menor a dos d√≠as posteriores "
                  f"({dos_dias_despues.strftime('%m-%d-%Y')}).")
            uso = input(f"¬øDeseas usar {dos_dias_despues.strftime('%m-%d-%Y')} como fecha inicio? (S/N): ").strip().upper()
            if uso == "S":
                f1 = dos_dias_despues
                print(f" Se usar√° {f1.strftime('%m-%d-%Y')} como fecha inicio.\n")
            else:
                print(" Continuando con la fecha original.\n")

        entrada_f2 = input("Fecha fin del rango (mm-dd-yyyy) o C para cancelar: ").strip()
        if entrada_f2.upper() == "C":
            print("Operaci√≥n cancelada.")
            return
        f2 = validar_fecha(entrada_f2, False)
        if not f2:
            print("Fecha de fin inv√°lida, intenta de nuevo o ingresa C para cancelar.")
            continue

        if f1 > f2:
            print("Rango inv√°lido: la fecha de inicio es posterior a la fecha fin. Intenta de nuevo.")
            continue

        break

    rango = {
        folio: res
        for folio, res in lista_reservas.items()
        if f1 <= res['fecha'] <= f2 and not res.get('cancelado', False)
    }

    if not rango:
        print("No hay reservas no canceladas en ese rango.")
        return

    print(f"\n{'Folio':<6} {'Cliente':<25} {'Sala':<15} {'Fecha':<12} {'Turno':<6} {'Evento':<20}")
    for folio, res in rango.items():
        cli = lista_clientes[res['cliente']]
        sala = lista_salas[res['sala']]
        nombre_cliente = f"{cli['apellidos']} {cli['nombre']}"
        print(f"{folio:<6} {nombre_cliente:<25} {sala['nombre']:<15} {res['fecha'].strftime('%m-%d-%Y'):<12} {res['turno']:<6} {res['evento']:<20}")

    while True:
        sel = input("\nIngresa el folio que deseas cancelar (o C para cancelar operaci√≥n): ").strip().upper()
        if sel == "C":
            print("Operaci√≥n cancelada.")
            return
        if not sel.isdigit() or int(sel) not in rango:
            print("Folio inv√°lido, intenta de nuevo o ingresa C para cancelar.")
            continue

        folio_sel = int(sel)
        reserva = lista_reservas[folio_sel]

        if reserva['fecha'] < dos_dias_despues:
            print(f" La reserva con folio {folio_sel} tiene fecha {reserva['fecha'].strftime('%m-%d-%Y')} "
                  f"y no cumple con los 2 d√≠as de anticipaci√≥n. Operaci√≥n rechazada.")
            return

        confirmar = input(
            f"Confirmas la cancelaci√≥n de la reserva {folio_sel} "
            f"(Evento: {reserva['evento']}, Fecha: {reserva['fecha'].strftime('%m-%d-%Y')})? (S/N): "
        ).strip().upper()

        if confirmar == "S":
            lista_reservas[folio_sel]['cancelado'] = True
            marcar_reserva_cancelada_db(folio_sel)
            print(f" Reserva {folio_sel} registrada como CANCELADA. Disponibilidad recuperada.")
            return
        else:
            print("Cancelaci√≥n abortada por el usuario.")
            return


def consultar_reservas():
    if not lista_reservas:
        print("No hay fechas registradas.")
        return

    fecha_input = input("Fecha a consultar (mm-dd-yyyy) o presiona Enter para usar la fecha actual, o C para cancelar: ").strip()

    if fecha_input.upper() == "C":
        return
    elif fecha_input == "":
        fecha_valida = datetime.date.today()
        print(f"Se usar√° la fecha actual del sistema: {fecha_valida.strftime('%m-%d-%Y')}")
    else:
        fecha_valida = validar_fecha(fecha_input, False)
        if not fecha_valida:
            print("Fecha inv√°lida.")
            return

    hay = reporte_fecha(fecha_valida)
    if hay:
        print("\nFormatos disponibles para exportar:")
        print("1. CSV")
        print("2. JSON")
        print("3. Excel (.xlsx)")
        
        while True:
            op = input("Selecciona el formato (1-3) o presiona Enter para omitir: ").strip()
            if op == "":
                print("No se export√≥ ning√∫n archivo.")
                break
            if not op.isdigit() or int(op) not in [1, 2, 3]:
                print("Selecciona un formato dentro del rango (1-3).")
                continue

            op = int(op)
            if op == 1:
                exportar_csv(fecha_valida)
            elif op == 2:
                exportar_json(fecha_valida)
            elif op == 3:
                exportar_excel(fecha_valida)
            break

def menu():
    cargar_estado()
    while True:
        print("\n--- Men√∫ Principal ---")
        print("1. Registrar nueva reserva de sala")
        print("2. Editar el nombre de un evento")
        print("3. Consultar reservas por fecha")
        print("4. Registrar nuevo cliente")
        print("5. Registrar nueva sala")
        print("6. Cancelar una reservaci√≥n")
        print("7. Salir del sistema")
        opcion = input("Elige una opci√≥n: ")
        
        if opcion == "1":
            registrar_reserva()
        elif opcion == "2":
            editar_evento()
        elif opcion == "3":
            consultar_reservas()
        elif opcion == "4":
            registrar_cliente()
        elif opcion == "5":
            registrar_sala()
        elif opcion == "6":
            cancelar_reserva()
        elif opcion == "7":
            confirmar = input("¬øSeguro que deseas salir? (S/N): ").upper()
            if confirmar == "S":
                print("Saliendo del sistema...")
                break
            else:
                print("Salida cancelada. Regresando al men√∫ principal.")
        else:
            print("Opci√≥n inv√°lida.")

menu()



